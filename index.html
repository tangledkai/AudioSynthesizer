<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TangledKai Synth v1.5.0</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        /* MP3 匯出進度條 */
        #export-loader-bg {
            display: none; position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.35); z-index: 3000; justify-content: center; align-items: center;
        }
        #export-loader-box {
            background: #222; border-radius: 16px; box-shadow: 0 8px 32px #000a; padding: 32px 28px 24px 28px;
            min-width: 320px; display: flex; flex-direction: column; align-items: center;
        }
        #export-loader-label { color: #ffd700; font-size: 1.1em; margin-bottom: 18px; }
        .loader { display: block; position: relative; height: 12px; width: 80%; border: 1px solid #fff; border-radius: 10px; overflow: hidden; background: #111; }
    .loader-bar { position: absolute; left: 0; top: 0; height: 100%; width: 0; background: #ffd700; transition: width 0.2s linear; }
        #export-loader-time { color: #ffd700; margin-top: 12px; }

        .modal-rate-bg {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.35); justify-content: center; align-items: center;
        }
        .modal-rate {
            background: #222; border-radius: 16px; box-shadow: 0 8px 32px #000a; padding: 32px 28px 24px 28px;
            min-width: 320px; display: flex; flex-direction: column; align-items: center;
        }
        .modal-rate label { color: #ffd700; font-size: 1.1em; margin-bottom: 12px; }
        .modal-rate input[type="number"] {
            width: 120px; padding: 10px; font-size: 1.2em; border-radius: 8px; border: 1px solid #ffd700; margin-bottom: 18px; background: #111; color: #ffd700;
        }
        .modal-rate .modal-btns { display: flex; gap: 18px; }
        .modal-rate button {
            padding: 8px 22px; border-radius: 8px; border: none; font-size: 1em; cursor: pointer;
            background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%); color: #222; font-weight: bold;
        }
        .modal-rate button.cancel { background: #444; color: #eee; }
        .context-menu {
            position: fixed;
            display: none;
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 100%);
            border-radius: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.7);
            z-index: 1000;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        .context-menu ul {
            list-style: none;
            margin: 0;
            padding: 8px 0;
        }
        .context-menu li {
            padding: 10px 25px;
            color: rgba(255, 215, 0, 0.9);
            cursor: pointer;
            font-size: 14px;
        }
        .context-menu li:hover {
            background-color: rgba(255, 215, 0, 0.15);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 25%, #2d2d2d 50%, #1a1a1a 75%, #0a0a0a 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        .main-container { display: flex; gap: 35px; width: 100%; max-width: 1600px; height: 90vh; /* Set a fixed height */ }
        .synthesizer, .sequencer-panel {
            background: linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%);
            border-radius: 25px; padding: 35px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 215, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        .synthesizer { flex: 3; min-width: 800px; }
        .sequencer-panel { flex: 2; }

        h1, h2, h3 {
            background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%);
            background-clip: text;
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            text-align: center; font-weight: 700;
            flex-shrink: 0;
        }
        h1 { font-size: 2.8em; margin-bottom: 35px; }
        h2 { font-size: 1.8em; margin-bottom: 20px; }
        h3 { font-size: 1.3em; margin-bottom: 20px; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 25px; margin-bottom: 30px; flex-shrink: 0; }
        .control-group { background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 100%); padding: 25px; border-radius: 20px; border: 1px solid rgba(255, 215, 0, 0.15); }
        .control { margin-bottom: 15px; }
        .control label { display: block; color: rgba(255, 215, 0, 0.9); margin-bottom: 8px; font-size: 0.95em; }
        input[type="range"] { appearance: none; -webkit-appearance: none; width: 100%; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { height: 8px; background: linear-gradient(90deg, #333, #1a1a1a); border-radius: 4px; border: 1px solid rgba(255, 215, 0, 0.2); }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; margin-top: -9px; background: linear-gradient(135deg, #ffd700 0%, #ffb700 50%, #ffd700 100%); border-radius: 50%; cursor: pointer; border: 2px solid #1a1a1a; box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4); }
        select { width: 100%; padding: 12px 16px; background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 12px; color: #ffd700; }
        
        .octave-selector { display: flex; justify-content: center; gap: 15px; margin-bottom: 25px; flex-shrink: 0; }
        .octave-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border: 2px solid rgba(255, 215, 0, 0.3); color: rgba(255, 215, 0, 0.6);
            padding: 10px 20px; border-radius: 12px; font-size: 1em; cursor: pointer; transition: all 0.2s ease;
        }
        .octave-btn.active { color: #1a1a1a; background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }

        .keyboard { display: flex; justify-content: center; margin-top: 20px; flex-wrap: wrap; gap: 2px; height: 160px; flex-shrink: 0; }
        .key { width: 45px; height: 150px; background: #f5f5f5; border: 2px solid #bbb; border-radius: 0 0 12px 12px; cursor: pointer; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 12px; font-size: 12px; color: #333; transition: all 0.1s ease-out; user-select: none; }
        .key.active { background: linear-gradient(180deg, #ffd700 0%, #ffb700 50%, #ff8f00 100%); transform: translateY(6px); box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
        .black-key { background: #1a1a1a; color: #ffd700; height: 100px; width: 28px; margin: 0 -14px; z-index: 1; border-radius: 0 0 8px 8px; }
        .black-key.active { background: linear-gradient(180deg, #ffb700 0%, #ff8f00 100%); transform: translateY(4px); box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        .value-display { color: rgba(255, 215, 0, 0.8); font-size: 0.85em; text-align: right; margin-top: 5px;}
        
        .sequencer-top-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-shrink: 0; }
        .toggles-container { display: flex; gap: 20px; }
        .loop-toggle { display: flex; align-items: center; gap: 10px; color: rgba(255, 215, 0, 0.8); cursor: pointer; font-size: 0.9em; }
        .loop-toggle input { display: none; }
        .loop-toggle .toggle-switch { width: 40px; height: 22px; background: #333; border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 11px; position: relative; transition: background-color 0.3s ease; }
        .loop-toggle .toggle-switch::before { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #aaa; border-radius: 50%; transition: transform 0.3s ease; }
        .loop-toggle input:checked + .toggle-switch { background-color: #ffd700; }
        .loop-toggle input:checked + .toggle-switch::before { background-color: #1a1a1a; transform: translateX(18px); }

        .sequencer-editor-container { display: flex; position: relative; flex-grow: 1; background-color: transparent; border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 12px; overflow: hidden; }
        #line-numbers {
            font-family: 'Courier New', Courier, monospace; font-size: 16px; line-height: 1.6; padding: 15px 10px; width: 60px;
            text-align: right; user-select: none; overflow: hidden; border-radius: 10px 0 0 10px; flex-shrink: 0;
            background-color: #111;
        }
        .line-number-item { color: rgba(255, 215, 0, 0.4); transition: color 0.2s ease; }
        .line-number-item.active { color: #ffd700; font-weight: bold; }

        .sequencer-editor { position: relative; flex-grow: 1; overflow-y: auto; }
        #sequencerCode, #sequencerHighlight {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 15px; font-family: 'Courier New', Courier, monospace;
            font-size: 16px; line-height: 1.6; border-radius: 0 10px 10px 0; white-space: pre; overflow-wrap: normal;
            border: none;
        }
        #sequencerHighlight { color: transparent; background-color: transparent; z-index: 1; pointer-events: none; overflow-y: scroll; }
        #editing-highlight-bar { position: absolute; width: 100%; background-color: rgba(255, 215, 0, 0.15); z-index: -2; display: none; }
        .highlight-bar { position: absolute; width: 100%; background-color: rgba(0, 200, 255, 0.2); z-index: -1; transition: top 0.1s ease-out; }
        #sequencerCode { background-color: transparent; color: #ffd700; resize: none; z-index: 2; overflow-x: auto; overflow-y: scroll; }
        #sequencerCode:disabled { cursor: not-allowed; opacity: 0.6; }
        .sequencer-editor-container:focus-within { border-color: #ffd700; }
        #sequencerCode:focus { outline: none; }

        .sequencer-buttons { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 20px; flex-shrink: 0; }
        .sequencer-buttons button { flex-grow: 1; padding: 15px; font-size: 1.1em; color: #1a1a1a; background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%); border: none; border-radius: 12px; cursor: pointer; min-width: 100px; }
        .sequencer-buttons button:disabled { background: #555; color: #888; cursor: not-allowed; }
        .sequencer-buttons button#stopSequenceBtn { background: linear-gradient(135deg, #555 0%, #333 100%); color: #ccc; }
        .footer-link { position: fixed; bottom: 15px; left: 20px; color: #8fb1bf; text-decoration: none; font-size: 14px; transition: color 0.3s ease; }
        .footer-link:hover { color: #b3d7e8; }
        .hidden-control { display: none; }
        .lang-switcher { position: fixed; top: 20px; left: 20px; z-index: 1000; }
        .lang-switcher button { color: #8fb1bf; text-decoration: none; font-size: 14px; background-color: rgba(20, 20, 20, 0.5); padding: 8px 12px; border-radius: 8px; transition: all 0.3s ease; border: 1px solid rgba(255, 215, 0, 0.2); cursor: pointer;}
        .lang-switcher button:hover { background-color: rgba(40, 40, 40, 0.8); color: #fff; }
        @media (max-width: 1200px) { body { height: auto; overflow: auto; } .main-container { flex-direction: column; height: auto; } }
    </style>
</head>
<body>
    <div id="sequencer-context-menu" class="context-menu">
        <ul>
            <li data-action="sync-rate">同步速率</li>
        </ul>
    </div>
    <!-- 自訂同步速率 modal -->
    <div id="modal-rate-bg" class="modal-rate-bg">
        <div class="modal-rate">
            <label for="modal-rate-input">請輸入新的同步速率 (毫秒)：</label>
            <input id="modal-rate-input" type="number" min="1" max="10000" value="150" />
            <div class="modal-btns">
                <button id="modal-rate-ok">確定</button>
                <button id="modal-rate-cancel" class="cancel">取消</button>
            </div>
        </div>
    </div>
    <div class="lang-switcher">
        <select id="lang-select">
            <option value="zh-TW">繁體中文</option>
            <option value="zh-CN">简体中文</option>
            <option value="en">English</option>
            <option value="ja">日本語</option>
            <option value="ko">한국어</option>
        </select>
    </div>
    <div class="main-container">
        <!-- MP3 匯出進度條 -->
        <div id="export-loader-bg">
            <div id="export-loader-box">
                <div id="export-loader-label">MP3 匯出中...</div>
                <div class="loader"><div class="loader-bar" id="export-loader-bar"></div></div>
                <div id="export-loader-time"></div>
            </div>
        </div>
        <div class="synthesizer">
            <h1 data-i18n-key="mainTitle">♬ Audio Synthesizer</h1>
            <div class="controls">
                <div class="control-group">
                    <h3 data-i18n-key="oscillatorTitle">Oscillator</h3>
                    <div class="control">
                        <label for="waveform" data-i18n-key="waveformLabel">Waveform Type</label>
                        <select id="waveform">
                            <option value="sine" data-i18n-key="waveSine">正弦波 (Sine)</option>
                            <option value="square" data-i18n-key="waveSquare">方波 (Square)</option>
                            <option value="sawtooth" data-i18n-key="waveSawtooth">鋸齒波 (Sawtooth)</option>
                            <option value="triangle" data-i18n-key="waveTriangle">三角波 (Triangle)</option>
                            <option value="pulse" data-i18n-key="wavePulse">脈衝波 (Pulse)</option>
                            <option value="noise" data-i18n-key="waveNoise">噪音 (Noise)</option>
                            <option value="fm" data-i18n-key="waveFM">FM 合成</option>
                        </select>
                    </div>
                    <div class="control">
                        <label for="volume" data-i18n-key="volumeLabel">Volume</label>
                        <input type="range" id="volume" min="0" max="1" step="0.01" value="0.3">
                        <div class="value-display" id="volumeValue">30%</div>
                    </div>
                    <div id="pulse-width-control" class="control hidden-control">
                        <label for="pulseWidth" data-i18n-key="pulseWidthLabel">Pulse Width</label>
                        <input type="range" id="pulseWidth" min="0.01" max="0.99" step="0.01" value="0.5">
                        <div class="value-display" id="pulseWidthValue">50%</div>
                    </div>
                    <div id="fm-depth-control" class="control hidden-control">
                        <label for="fmDepth" data-i18n-key="fmDepthLabel">FM Depth</label>
                        <input type="range" id="fmDepth" min="0" max="1000" step="1" value="100">
                        <div class="value-display" id="fmDepthValue">100</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3 data-i18n-key="filterTitle">Filter</h3>
                    <div class="control">
                        <label for="filterFreq" data-i18n-key="filterFreqLabel">Cutoff Frequency</label>
                        <input type="range" id="filterFreq" min="100" max="10000" step="10" value="1000">
                        <div class="value-display" id="filterFreqValue">1000 Hz</div>
                    </div>
                    <div class="control">
                        <label for="filterQ" data-i18n-key="filterQLabel">Resonance (Q)</label>
                        <input type="range" id="filterQ" min="0.1" max="30" step="0.1" value="1">
                        <div class="value-display" id="filterQValue">1.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3 data-i18n-key="envelopeTitle">Envelope</h3>
                    <div class="control">
                        <label for="attack" data-i18n-key="attackLabel">Attack Time</label>
                        <input type="range" id="attack" min="0" max="2" step="0.01" value="0.1">
                        <div class="value-display" id="attackValue">0.10s</div>
                    </div>
                    <div class="control">
                        <label for="release" data-i18n-key="releaseLabel">Release Time</label>
                        <input type="range" id="release" min="0" max="3" step="0.01" value="0.5">
                        <div class="value-display" id="releaseValue">0.50s</div>
                    </div>
                </div>
            </div>
            
            <div id="octave-selector" class="octave-selector"></div>
            
            <div id="keyboard" class="keyboard"></div>
        </div>
        <div class="sequencer-panel">
            <div class="sequencer-top-controls">
                <h2 data-i18n-key="sequencerTitle">Code Sequencer</h2>
                <div class="toggles-container">
                    <label class="loop-toggle">
                        <span data-i18n-key="loopLabel">循環</span>
                        <input type="checkbox" id="loop-toggle-checkbox">
                        <span class="toggle-switch"></span>
                    </label>
                    <label class="loop-toggle">
                        <span data-i18n-key="recordLabel">寫入</span>
                        <input type="checkbox" id="record-toggle-checkbox">
                        <span class="toggle-switch"></span>
                    </label>                    
                </div>
            </div>
             <div class="sequencer-editor-container">
                <div id="line-numbers"></div>
                <div class="sequencer-editor">
                    <pre id="sequencerHighlight"></pre>
                    <textarea id="sequencerCode" spellcheck="false"></textarea>
                </div>
             </div>
             <div class="sequencer-buttons">
                 <button id="playSequenceBtn" data-i18n-key="playBtn">Play</button>
                 <button id="stopSequenceBtn" data-i18n-key="stopBtn">Stop</button>
                 <button id="exportMp3Btn" data-i18n-key="exportBtn">Export MP3</button>
             </div>
        </div>
    </div>

    <a href="https://portaly.cc/tangledkai_2.0/" target="_blank" rel="noopener noreferrer" class="footer-link" data-i18n-key="authorLink">tangledkai_2.0 製作</a>

    <script>
        const translations = {
            'zh-TW': {
                mainTitle: '♬ 糾結合成器', sequencerTitle: '程式碼音序器', oscillatorTitle: '振盪器', waveformLabel: '波形類型',
                waveSine: '正弦波 (Sine)', waveSquare: '方波 (Square)', waveSawtooth: '鋸齒波 (Sawtooth)', waveTriangle: '三角波 (Triangle)',
                wavePulse: '脈衝波 (Pulse)', waveNoise: '噪音 (Noise)', waveFM: 'FM 合成', volumeLabel: '音量',
                pulseWidthLabel: '脈衝寬度', fmDepthLabel: 'FM 深度', filterTitle: '濾波器', filterFreqLabel: '截止頻率',
                filterQLabel: '共振 (Q值)', envelopeTitle: '包絡線', attackLabel: '起音時間', releaseLabel: '釋音時間',
                playBtn: '播放', stopBtn: '停止', exportBtn: '匯出 MP3', exportRendering: '渲染中...',
                exportEncoding: 'MP3編碼中...', authorLink: 'tangledkai_2.0 製作',
                sequencerPlaceholder: '語法: 音名 時長(毫秒)\n--- 代表休止符\n| 分隔同時播放的音符\n\n範例 (和弦):\nC4 500 | E4 500 | G4 500\n--- 250\nF3 500 | A3 500 | C4 500 \n\n循環:快捷鍵『]』 寫入:快捷鍵『|』\n音域切換:快捷鍵『~』&『1』\n\n同步速率:選取音符右鍵點選「同步速率」',
                langName: '繁體中文', loopLabel: '循環', recordLabel: '寫入'
            },
            'zh-CN': {
                mainTitle: '♬ 纠结合成器', sequencerTitle: '代码音序器', oscillatorTitle: '振荡器', waveformLabel: '波形类型',
                waveSine: '正弦波 (Sine)', waveSquare: '方波 (Square)', waveSawtooth: '锯齿波 (Sawtooth)', waveTriangle: '三角波 (Triangle)',
                wavePulse: '脉冲波 (Pulse)', waveNoise: '噪音 (Noise)', waveFM: 'FM 合成', volumeLabel: '音量',
                pulseWidthLabel: '脉冲宽度', fmDepthLabel: 'FM 深度', filterTitle: '滤波器', filterFreqLabel: '截止频率',
                filterQLabel: '共振 (Q值)', envelopeTitle: '包络线', attackLabel: '起音时间', releaseLabel: '释音时间',
                playBtn: '播放', stopBtn: '停止', exportBtn: '导出 MP3', exportRendering: '渲染中...',
                exportEncoding: 'MP3编码中...', authorLink: 'tangledkai_2.0 制作',
                sequencerPlaceholder: '语法: 音名 时长(毫秒)\n--- 代表休止符\n| 分隔同时播放的音符\n\n范例 (和弦):\nC4 500 | E4 500 | G4 500\n--- 250\nF3 500 | A3 500 | C4 500 \n\n循环:快捷键“]” 写入:快捷键“|”\n音域切换:快捷键“~”&“1”\n\n同步速率:选中音符右键点击“同步速率”',
                langName: '简体中文', loopLabel: '循环', recordLabel: '写入'
            },
            'en': {
                mainTitle: '♬ TangledKai Synth', sequencerTitle: 'Code Sequencer', oscillatorTitle: 'Oscillator', waveformLabel: 'Waveform Type',
                waveSine: 'Sine', waveSquare: 'Square', waveSawtooth: 'Sawtooth', waveTriangle: 'Triangle',
                wavePulse: 'Pulse', waveNoise: 'Noise', waveFM: 'FM Synthesis', volumeLabel: 'Volume',
                pulseWidthLabel: 'Pulse Width', fmDepthLabel: 'FM Depth', filterTitle: 'Filter', filterFreqLabel: 'Cutoff Frequency',
                filterQLabel: 'Resonance (Q)', envelopeTitle: 'Envelope', attackLabel: 'Attack Time', releaseLabel: 'Release Time',
                playBtn: 'Play', stopBtn: 'Stop', exportBtn: 'Export MP3', exportRendering: 'Rendering...',
                exportEncoding: 'Encoding MP3...', authorLink: 'Made by tangledkai_2.0',
                sequencerPlaceholder: 'Syntax: Note Duration(ms)\n--- for rests\n| to play notes simultaneously\n\nExample (Chord):\nC4 500 | E4 500 | G4 500\n--- 250\nF3 500 | A3 500 | C4 500 \n\nLoop: Shortcut \']\'  Write: Shortcut \'|\'\nOctave Switch: Shortcut \'~\' & \'1\'\n\nSync Rate: Select notes \nright-click and choose "Sync Rate"',
                langName: 'English', loopLabel: 'Loop', recordLabel: 'Record'
            },
            'ja': {
                mainTitle: '♬ もつれ合成器', sequencerTitle: 'コードシーケンサー', oscillatorTitle: 'オシレーター', waveformLabel: '波形タイプ',
                waveSine: 'サイン波 (Sine)', waveSquare: '矩形波 (Square)', waveSawtooth: 'ノコギリ波 (Sawtooth)', waveTriangle: '三角波 (Triangle)',
                wavePulse: 'パルス波 (Pulse)', waveNoise: 'ノイズ (Noise)', waveFM: 'FM 合成', volumeLabel: '音量',
                pulseWidthLabel: 'パルス幅', fmDepthLabel: 'FM 深度', filterTitle: 'フィルター', filterFreqLabel: 'カットオフ周波数',
                filterQLabel: 'レゾナンス (Q)', envelopeTitle: 'エンベロープ', attackLabel: 'アタックタイム', releaseLabel: 'リリースタイム',
                playBtn: '再生', stopBtn: '停止', exportBtn: 'MP3 書き出し', exportRendering: 'レンダリング中...',
                exportEncoding: 'MP3 エンコード中...', authorLink: 'tangledkai_2.0 制作',
                sequencerPlaceholder: '構文: 音名 時間(ミリ秒)\n--- 休符\n| 同時に再生\n\n例 (和音):\nC4 500 | E4 500 | G4 500\n--- 250\nF3 500 | A3 500 | C4 500 \n\nループ: ショートカット「]」 書き込み: ショートカット「|」\nオクターブ切替: ショートカット「~」＆「1」\n\n同期速度: 音符を選択し右クリックで「同期速度」',
                langName: '日本語', loopLabel: 'ループ', recordLabel: '記録'
            },
            'ko': {
                mainTitle: '♬ 얽힘 합성기', sequencerTitle: '코드 시퀀서', oscillatorTitle: '오실레이터', waveformLabel: '파형 종류',
                waveSine: '사인파 (Sine)', waveSquare: '사각파 (Square)', waveSawtooth: '톱니파 (Sawtooth)', waveTriangle: '삼각파 (Triangle)',
                wavePulse: '펄스파 (Pulse)', waveNoise: '노이즈 (Noise)', waveFM: 'FM 합성', volumeLabel: '볼륨',
                pulseWidthLabel: '펄스 폭', fmDepthLabel: 'FM 깊이', filterTitle: '필터', filterFreqLabel: '컷오프 주파수',
                filterQLabel: '공진 (Q)', envelopeTitle: '엔벨로프', attackLabel: '어택 타임', releaseLabel: '릴리즈 타임',
                playBtn: '재생', stopBtn: '정지', exportBtn: 'MP3 내보내기', exportRendering: '렌더링 중...',
                exportEncoding: 'MP3 인코딩 중...', authorLink: 'tangledkai_2.0 제작',
                sequencerPlaceholder: '구문: 음 이름 시간(밀리초)\n--- 쉼표\n| 동시에 재생\n\n예시 (코드):\nC4 500 | E4 500 | G4 500\n--- 250\nF3 500 | A3 500 | C4 500 \n\n루프: 단축키 \']\'  입력: 단축키 \'|\'\n옥타브 전환: 단축키 \'~\' & \'1\'\n\n동기화 속도: 음표 선택 후 우클릭 "동기화 속도"',
                langName: '한국어', loopLabel: '루프', recordLabel: '기록'
            }
        };

        class SimpleSynthesizer {
            constructor() {
                this.audioContext = null;
                this.liveAudioContext = null;
                this.activeOscillators = new Map();
                this.isPlayingSequence = false;
                this.isExporting = false;
                this.isLooping = false;
                this.isRecording = false;
                this.recordingNotes = new Map();
                this.completedNotesBuffer = []; // FIX: Re-initialize buffer
                this.writeBufferTimeout = null; // FIX: Re-initialize timeout
                this.sequenceTimeouts = [];
                this.currentLanguage = 'zh-TW';
                this.currentLine = 0;

                this.settings = { waveform: 'sine', volume: 0.3, filterFreq: 1000, filterQ: 1, attack: 0.1, release: 0.5, pulseWidth: 0.5, fmDepth: 100 };
                
                this.noteFrequencies = {
                    'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
                    'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
                    'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
                    'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
                    'C6': 1046.50, 'C#6': 1108.73, 'D6': 1174.66, 'D#6': 1244.51, 'E6': 1318.51, 'F6': 1396.91, 'F#6': 1479.98, 'G6': 1567.98, 'G#6': 1661.22, 'A6': 1760.00, 'A#6': 1864.66, 'B6': 1975.53
                };
                
                this.octaveRanges = [2, 3, 4];
                this.currentOctaveIndex = 1;
                this.keyMap = {};
                
                this.initDomElements();
                this.initAudio();
                this.setupEventListeners();
                this.setLanguage(this.currentLanguage);
                
                this.setOctaveView(this.currentOctaveIndex);
                this.syncHighlighterContent();
                this.updateLineNumbers();
                this.updateCursorHighlight();
                this.initContextMenu(); // <-- 新增這一行
            }
            
            initDomElements() {
                this.langSelect = document.getElementById('lang-select');
                this.pulseWidthControl = document.getElementById('pulse-width-control');
                this.fmDepthControl = document.getElementById('fm-depth-control');
                this.sequencerCodeEl = document.getElementById('sequencerCode');
                this.sequencerHighlightEl = document.getElementById('sequencerHighlight');
                this.playBtn = document.getElementById('playSequenceBtn');
                this.stopBtn = document.getElementById('stopSequenceBtn');
                this.exportBtn = document.getElementById('exportMp3Btn');
                this.keyboardEl = document.getElementById('keyboard');
                this.octaveSelectorEl = document.getElementById('octave-selector');
                this.lineNumbersEl = document.getElementById('line-numbers');
                this.loopToggleCheckbox = document.getElementById('loop-toggle-checkbox');
                this.recordToggleCheckbox = document.getElementById('record-toggle-checkbox');
                this.contextMenuEl = document.getElementById('sequencer-context-menu'); // <-- 新增這一行
            }

            setLanguage(lang) {
                this.currentLanguage = lang;
                const langDict = translations[lang];
                document.querySelectorAll('[data-i18n-key]').forEach(element => {
                    const key = element.getAttribute('data-i18n-key');
                    if (langDict[key]) {
                        element.textContent = langDict[key];
                    }
                });
                this.sequencerCodeEl.placeholder = langDict.sequencerPlaceholder;
                // 設定下拉選單顯示當前語言
                if (this.langSelect) this.langSelect.value = lang;
                this.updateDisplayValues();
                this.updateLineNumbers();
            }
            
            setupEventListeners() {
                this.langSelect.addEventListener('change', (e) => {
                    this.setLanguage(e.target.value);
                });

                this.playBtn.addEventListener('click', () => this.playSequence());
                this.stopBtn.addEventListener('click', () => this.stopSequence());
                this.exportBtn.addEventListener('click', () => this.exportToMp3());
                this.loopToggleCheckbox.addEventListener('change', (e) => {
                    this.isLooping = e.target.checked;
                });
                this.recordToggleCheckbox.addEventListener('change', (e) => {
                    this.isRecording = e.target.checked;
                    this.sequencerCodeEl.disabled = this.isRecording;
                    if (!this.isRecording) {
                        this.sequencerCodeEl.focus();
                    }
                });

                document.getElementById('waveform').addEventListener('change', (e) => {
                    this.settings.waveform = e.target.value;
                    this.toggleCustomControls();
                });
                
                const sliders = {
                    volume: (val) => { this.settings.volume = val; },
                    filterFreq: (val) => { this.settings.filterFreq = val; },
                    filterQ: (val) => { this.settings.filterQ = val; },
                    attack: (val) => { this.settings.attack = val; },
                    release: (val) => { this.settings.release = val; },
                    pulseWidth: (val) => { this.settings.pulseWidth = val; },
                    fmDepth: (val) => { this.settings.fmDepth = val; },
                };
                for (const [id, setter] of Object.entries(sliders)) {
                    document.getElementById(id)?.addEventListener('input', (e) => {
                        setter(parseFloat(e.target.value));
                        this.updateDisplayValues();
                    });
                }
                
                document.addEventListener('keydown', (e) => {
                    if (e.target === this.sequencerCodeEl) return;
                    if (this._keyboardEnabled === false) return;
                    if (e.key === '`' || e.key === '~') { this.changeOctave(-1); return; }
                    if (e.key === '1') { this.changeOctave(1); return; }

                    if (e.key === ']') {
                        this.loopToggleCheckbox.checked = !this.loopToggleCheckbox.checked;
                        this.isLooping = this.loopToggleCheckbox.checked;
                        return;
                    }
                    if (e.key === '\\') {
                        this.recordToggleCheckbox.checked = !this.recordToggleCheckbox.checked;
                        this.isRecording = this.recordToggleCheckbox.checked;
                        this.sequencerCodeEl.disabled = this.isRecording;
                        return;
                    }
                    const note = this.keyMap[e.key.toLowerCase()];
                    if (note && !e.repeat && !this.activeOscillators.has(note)) {
                        this.playNote(note);
                        const keyEl = document.querySelector(`[data-note="${note}"]`);
                        if (keyEl) keyEl.classList.add('active');
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.target === this.sequencerCodeEl) return;
                    if (this._keyboardEnabled === false) return;
                    const note = this.keyMap[e.key.toLowerCase()];
                    if (note) {
                        this.stopNote(note);
                        const keyEl = document.querySelector(`[data-note="${note}"]`);
                        if (keyEl) keyEl.classList.remove('active');
                    }
                });
                
                this.sequencerCodeEl.addEventListener('scroll', () => {
                    this.sequencerHighlightEl.scrollTop = this.sequencerCodeEl.scrollTop;
                    this.lineNumbersEl.scrollTop = this.sequencerCodeEl.scrollTop;
                });
                
                this.sequencerCodeEl.addEventListener('input', () => {
                    this.sequencerHighlightEl.textContent = this.sequencerCodeEl.value;
                    this.syncHighlighterContent();
                    this.updateLineNumbers();
                    this.updateCursorHighlight();
                });

                this.sequencerCodeEl.addEventListener('click', () => this.updateCursorHighlight());
                this.sequencerCodeEl.addEventListener('keyup', () => this.updateCursorHighlight());
                this.sequencerCodeEl.addEventListener('focus', () => this.updateCursorHighlight());
            }
            
            initContextMenu() {
                const textarea = this.sequencerCodeEl;
                textarea.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    setTimeout(() => textarea.focus(), 0);
                    const selection = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
                    if (selection.trim().length > 0) {
                        this.contextMenuEl.style.top = `${e.clientY}px`;
                        this.contextMenuEl.style.left = `${e.clientX}px`;
                        this.contextMenuEl.style.display = 'block';
                    } else {
                        this.contextMenuEl.style.display = 'none';
                    }
                });
                document.addEventListener('mousedown', (e) => {
                    if (!this.contextMenuEl.contains(e.target)) {
                        this.contextMenuEl.style.display = 'none';
                    }
                });
                this.contextMenuEl.addEventListener('click', (e) => {
                    const action = e.target.getAttribute('data-action');
                    if (!action) return;
                    if (action === 'sync-rate') {
                        this.contextMenuEl.style.display = 'none';
                        this.showRateModal();
                    }
                    this.contextMenuEl.style.display = 'none';
                });

                // Modal 事件
                this.modalRateBg = document.getElementById('modal-rate-bg');
                this.modalRateInput = document.getElementById('modal-rate-input');
                this.modalRateOk = document.getElementById('modal-rate-ok');
                this.modalRateCancel = document.getElementById('modal-rate-cancel');
                this._modalRateSelection = null;
                this.modalRateOk.addEventListener('click', () => {
                    // 按下確定時，重新取得 textarea 的選取範圍與內容
                    const textarea = this.sequencerCodeEl;
                    textarea.focus();
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const selection = textarea.value.substring(start, end);
                    const val = this.modalRateInput.value;
                    if (val && !isNaN(val) && selection.length > 0) {
                        const newRate = parseInt(val, 10);
                        const updatedText = this.synchronizeRateAll(selection, newRate);
                        this.replaceSelection(updatedText, start, end);
                        this.hideRateModal();
                    }
                });
                this.modalRateCancel.addEventListener('click', () => this.hideRateModal());
                this.modalRateInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') this.modalRateOk.click();
                    if (e.key === 'Escape') this.hideRateModal();
                });
            }

            showRateModal() {
                // 彈出 modal 前，暫停琴鍵功能與音色
                this._keyboardEnabled = false;
                if (typeof this.stopAllNotes === 'function') {
                    this.stopAllNotes();
                } else if (typeof this.stopAllSounds === 'function') {
                    this.stopAllSounds();
                }
                const textarea = this.sequencerCodeEl;
                textarea.blur();
                setTimeout(() => {
                    this.modalRateInput.value = '150';
                    this.modalRateBg.style.display = 'flex';
                    this.modalRateInput.focus();
                }, 30);
            }
            hideRateModal() {
                this.modalRateBg.style.display = 'none';
                // 關閉 modal 後恢復琴鍵功能與音色
                this._keyboardEnabled = true;
                if (typeof this.resumeAllSounds === 'function') {
                    this.resumeAllSounds();
                }
                this.sequencerCodeEl.focus();
            }

            // 將每個音符的速率都同步（每個音符後的數字都改，支援多個音符與升降記號）
            synchronizeRateAll(text, newRate) {
                // 允許多行，每行多個音符（| 分隔），每個音符格式: 名稱 數字
                // 名稱: A-G, 可有#或b, 一位數字, 後面可有多餘空格
                // 例: G#4 150, A#4 150, F3 150
                return text.replace(/([A-G][#b]?\d+)\s*\d+/g, (match, note) => `${note} ${newRate}`);
            }

            // 替換選取內容（可指定 start/end）
            replaceSelection(newText, start, end) {
                const textarea = this.sequencerCodeEl;
                if (typeof start !== 'number' || typeof end !== 'number') {
                    start = textarea.selectionStart;
                    end = textarea.selectionEnd;
                }
                const textBefore = textarea.value.substring(0, start);
                const textAfter = textarea.value.substring(end);
                textarea.value = textBefore + newText + textAfter;
                textarea.selectionStart = start;
                textarea.selectionEnd = start + newText.length;
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                textarea.focus();
            }
            // 琴鍵事件攔截（需在 keydown/keyup 事件處加判斷 this._keyboardEnabled）
            // ...existing code...

            // 輔助方法：同步速率
            synchronizeRate(text, newRate) {
                return text.split('\n').map(line => {
                    return line.split('|').map(part => {
                        const trimmedPart = part.trim();
                        if (trimmedPart === '') return part;

                        const segments = trimmedPart.split(/\s+/); // 用空白分割
                        if (segments.length >= 2 && !isNaN(segments[segments.length - 1])) {
                            segments[segments.length - 1] = newRate; // 只替換最後一個數字
                            return segments.join(' ');
                        }
                        return part; // 如果格式不符，返回原樣
                    }).join(' | ');
                }).join('\n');
            }

            // 輔助方法：替換選取內容
            replaceSelection(newText) {
                const textarea = this.sequencerCodeEl;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;

                // 手動觸發 input 事件，確保行號等UI能同步更新
                document.execCommand('insertText', false, newText);
                
                // 選取剛替換的內容
                textarea.focus();
                textarea.selectionStart = start;
                textarea.selectionEnd = start + newText.length;
            }
            updateLineNumbers() {
                this.lineNumbersEl.innerHTML = ''; 
                const lineCount = this.sequencerCodeEl.value.split('\n').length || 1;
                for (let i = 1; i <= lineCount; i++) {
                    const numberDiv = document.createElement('div');
                    numberDiv.className = 'line-number-item';
                    const prefix = String.fromCharCode('A'.charCodeAt(0) + Math.floor((i - 1) / 99));
                    const number = String((i - 1) % 99 + 1).padStart(2, '0');
                    numberDiv.textContent = `${prefix}${number}`;
                    this.lineNumbersEl.appendChild(numberDiv);
                }
            }

            updateCursorHighlight() {
                if(this.isPlayingSequence) return;

                const textUpToCursor = this.sequencerCodeEl.value.substring(0, this.sequencerCodeEl.selectionStart);
                const cursorLine = (textUpToCursor.match(/\n/g) || []).length;
                
                this.lineNumbersEl.childNodes.forEach((div, index) => {
                    div.classList.toggle('active', index === cursorLine);
                });

                const lineHeight = parseFloat(getComputedStyle(this.sequencerCodeEl).lineHeight);
                this.editingHighlightBar.style.height = `${lineHeight}px`;
                this.editingHighlightBar.style.top = `${cursorLine * lineHeight}px`;
                this.editingHighlightBar.style.display = 'block';
            }

            setOctaveView(index) {
                this.currentOctaveIndex = index;
                this.generateOctaveButtons();
                this.generateKeyboard();
                this.attachKeyListeners();
                this.updateKeyMap();
            }

            changeOctave(direction) {
                // --- 修正開始 ---
                // 在切換音域前，先強制停止所有目前由鍵盤觸發的音符，並移除它們的視覺回饋
                const notesToStop = [...this.activeOscillators.keys()];
                notesToStop.forEach(note => {
                    this.stopNote(note);
                    const keyEl = document.querySelector(`.key[data-note="${note}"]`);
                    if (keyEl) {
                        keyEl.classList.remove('active');
                    }
                });
                // --- 修正結束 ---

                let newIndex = this.currentOctaveIndex + direction;
                if (newIndex < 0) newIndex = this.octaveRanges.length - 1;
                if (newIndex >= this.octaveRanges.length) newIndex = 0;
                this.setOctaveView(newIndex);
            }
            
            generateOctaveButtons() {
                this.octaveSelectorEl.innerHTML = '';
                this.octaveRanges.forEach((startOctave, index) => {
                    const button = document.createElement('button');
                    button.className = 'octave-btn';
                    button.textContent = `[ C${startOctave} – C${startOctave + 2} ]`;
                    if (index === this.currentOctaveIndex) button.classList.add('active');
                    button.addEventListener('click', () => this.setOctaveView(index));
                    this.octaveSelectorEl.appendChild(button);
                });
            }
            
            generateKeyboard() {
                this.keyboardEl.innerHTML = '';
                const startOctave = this.octaveRanges[this.currentOctaveIndex];
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                for (let octave = startOctave; octave < startOctave + 3; octave++) {
                    noteNames.forEach(noteName => {
                        const note = `${noteName}${octave}`;
                        const key = document.createElement('div');
                        key.className = 'key';
                        if (noteName.includes('#')) key.classList.add('black-key');
                        key.dataset.note = note;
                        key.textContent = note;
                        this.keyboardEl.appendChild(key);
                    });
                }
            }

            attachKeyListeners() {
                document.querySelectorAll('.key').forEach(key => {
                    const note = key.dataset.note;
                    const stopHandler = () => {
                        this.stopNote(note);
                        key.classList.remove('active');
                    };
                    key.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.playNote(note);
                        key.classList.add('active');
                    });
                    key.addEventListener('mouseup', stopHandler);
                    key.addEventListener('mouseleave', () => {
                        if (this.activeOscillators.has(note)) stopHandler();
                    });
                });
            }
                /*  ['z', 's', 'x', 'd', 'c', 'v', 'g', 'b', 'h', 'n', 'j', 'm'],
                    ['q', '2', 'w', '3', 'e', 'r', '5', 't', '6', 'y', '7', 'u'],
                    ['i', '9', 'o', '0', 'p', '[', '=', ']']*/
            updateKeyMap() {
                const startOctave = this.octaveRanges[this.currentOctaveIndex];
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const keyRows = [
                    ['z', 's', 'x', 'd', 'c', 'v', 'g', 'b', 'h', 'n', 'j', 'm'],
                    [',', 'l', '.', ';', '/', 'q', '2', 'w', '3', 'e', '4', 'r'],
                    ['t', '6', 'y', '7', 'u', 'i', '9', 'o', '0', 'p', '-', '[']

                ];
                this.keyMap = {};
                keyRows.forEach((row, rowIndex) => {
                    const currentOctave = startOctave + rowIndex;
                    row.forEach((keyChar, noteIndex) => {
                        if (noteNames[noteIndex]) {
                            this.keyMap[keyChar] = `${noteNames[noteIndex]}${currentOctave}`;
                        }
                    });
                });
            }

            playSequence(isLoop = false) {
                if (this.isPlayingSequence || this.isExporting) return;
                
                if (!isLoop) {
                    const textUpToCursor = this.sequencerCodeEl.value.substring(0, this.sequencerCodeEl.selectionStart);
                    this.currentLine = (textUpToCursor.match(/\n/g) || []).length;
                }
                
                this.stopSequence();
                this.editingHighlightBar.style.display = 'none'; 

                this.liveAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.liveAudioContext.state === 'suspended') this.liveAudioContext.resume();
                
                this.isPlayingSequence = true;
                this.playBtn.disabled = true;
                this.exportBtn.disabled = true;
            
                const onStepCallback = (actualLineIndex, time) => {
                    this.sequenceTimeouts.push(setTimeout(() => {
                        if (!this.isPlayingSequence) return;
                        this.updateHighlight(actualLineIndex);
                    }, time));
                };
            
                const onNoteCallback = (note, time, duration) => {
                    const keyEl = document.querySelector(`[data-note="${note}"]`);
                    if (!keyEl) return;
                    this.sequenceTimeouts.push(setTimeout(() => {
                        if (!this.isPlayingSequence) return;
                        keyEl.classList.add('active');
                    }, time));
                    this.sequenceTimeouts.push(setTimeout(() => {
                        if (!this.isPlayingSequence) return;
                        keyEl.classList.remove('active');
                    }, time + duration));
                };
            
                const totalDuration = this.scheduleSequence(this.liveAudioContext, onStepCallback, onNoteCallback, this.currentLine);
            
                this.sequenceTimeouts.push(setTimeout(() => {
                    this.stopSequence(true);
                }, totalDuration));
            }

            stopSequence(isNaturalEnd = false) {
                if (this.liveAudioContext) {
                    this.liveAudioContext.close().catch(e => {});
                    this.liveAudioContext = null;
                }
                this.sequenceTimeouts.forEach(clearTimeout);
                this.sequenceTimeouts = [];
                
                this.isPlayingSequence = false;
                this.playBtn.disabled = false;
                this.exportBtn.disabled = false;
                document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
                
                if (isNaturalEnd && this.isLooping) {
                    this.currentLine = 0;
                    this.playSequence(true);
                } else {
                    if (isNaturalEnd) this.currentLine = 0;
                    this.updateHighlight(-1);
                    this.updateCursorHighlight();
                }
            }
            
            async exportToMp3() {
                if (this.isExporting || this.isPlayingSequence) return;
                this.isExporting = true;
                this._keyboardEnabled = false; // 暫停所有按鍵
                this.exportBtn.textContent = translations[this.currentLanguage].exportRendering;
                this.playBtn.disabled = true;
                this.exportBtn.disabled = true;

                // 顯示 loader
                const loaderBg = document.getElementById('export-loader-bg');
                const loaderBar = document.getElementById('export-loader-bar');
                const loaderTime = document.getElementById('export-loader-time');
                loaderBg.style.display = 'flex';
                loaderBar.style.width = '0%';
                loaderTime.textContent = '';

                try {
                    const totalDurationMs = this.calculateSequenceDuration();
                    if (totalDurationMs <= 0) {
                        alert("沒有可匯出的音樂內容。");
                        throw new Error("No content to export");
                    }
                    // 動態進度條
                    let elapsed = 0;
                    const totalSec = Math.ceil(totalDurationMs / 1000);
                    loaderTime.textContent = `預計剩餘：${totalSec} 秒`;
                    let interval = setInterval(() => {
                        elapsed += 0.2;
                        let percent = Math.min(90, (elapsed / totalSec) * 90); // 最多到90%
                        loaderBar.style.width = percent + '%';
                        let remain = Math.max(0, Math.ceil(totalSec - elapsed));
                        loaderTime.textContent = `預計剩餘：${remain} 秒`;
                    }, 200);

                    const sampleRate = 44100;
                    const offlineCtx = new OfflineAudioContext(1, sampleRate * (totalDurationMs / 1000), sampleRate);
                    this.scheduleSequence(offlineCtx, null, null, 0);
                    const renderedBuffer = await offlineCtx.startRendering();

                    clearInterval(interval);
                    loaderBar.style.width = '90%';
                    loaderTime.textContent = 'MP3 編碼中...';

                    this.exportBtn.textContent = translations[this.currentLanguage].exportEncoding;
                    // 模擬編碼進度條 90%~100%
                    let percent = 90;
                    let encodingInterval = setInterval(() => {
                        percent += 2;
                        loaderBar.style.width = Math.min(percent, 100) + '%';
                        if (percent >= 100) clearInterval(encodingInterval);
                    }, 80);

                    const mp3Data = this.encodeBufferToMp3(renderedBuffer);
                    const blob = new Blob(mp3Data, { type: 'audio/mp3' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `music-export-${Date.now()}.mp3`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    loaderBar.style.width = '100%';
                    loaderTime.textContent = '完成！';
                    clearInterval(encodingInterval);
                    await new Promise(r => setTimeout(r, 600)); // 停留0.6秒再關閉
                } catch (e) {
                    console.error("匯出失敗:", e);
                    if (e.message !== "No content to export") alert("匯出MP3時發生錯誤。");
                } finally {
                    loaderBg.style.display = 'none';
                    this.isExporting = false;
                    this._keyboardEnabled = true;
                    this.exportBtn.textContent = translations[this.currentLanguage].exportBtn;
                    this.playBtn.disabled = false;
                    this.exportBtn.disabled = false;
                }
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) { console.error('Web Audio API is not supported in this browser'); }
            }

            toggleCustomControls() {
                this.pulseWidthControl.classList.toggle('hidden-control', this.settings.waveform !== 'pulse');
                this.fmDepthControl.classList.toggle('hidden-control', this.settings.waveform !== 'fm');
            }

            syncHighlighterContent() {
                if (!this.sequencerHighlightEl) return;
                
                if (!this.sequencerHighlightEl.querySelector('.highlight-bar')) {
                    const bar = document.createElement('span');
                    bar.className = 'highlight-bar';
                    this.sequencerHighlightEl.appendChild(bar);
                }
                this.highlightBarEl = this.sequencerHighlightEl.querySelector('.highlight-bar');
                this.highlightBarEl.style.display = 'none';

                if (!this.sequencerHighlightEl.querySelector('#editing-highlight-bar')) {
                    const editingBar = document.createElement('span');
                    editingBar.id = 'editing-highlight-bar';
                    this.sequencerHighlightEl.appendChild(editingBar);
                }
                this.editingHighlightBar = this.sequencerHighlightEl.querySelector('#editing-highlight-bar');
            }

            updateDisplayValues() {
                document.getElementById('volumeValue').textContent = `${Math.round(this.settings.volume * 100)}%`;
                document.getElementById('filterFreqValue').textContent = `${this.settings.filterFreq} Hz`;
                document.getElementById('filterQValue').textContent = this.settings.filterQ.toFixed(1);
                document.getElementById('attackValue').textContent = `${this.settings.attack.toFixed(2)}s`;
                document.getElementById('releaseValue').textContent = `${this.settings.release.toFixed(2)}s`;
                if (this.settings.waveform === 'pulse') {
                    document.getElementById('pulseWidthValue').textContent = `${Math.round(this.settings.pulseWidth * 100)}%`;
                }
                if (this.settings.waveform === 'fm') {
                    document.getElementById('fmDepthValue').textContent = this.settings.fmDepth.toFixed(0);
                }
            }

            playNote(note) {
                if (!this.audioContext) this.initAudio();
                if (!this.audioContext || this.activeOscillators.has(note)) return;
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                if (this.isRecording) {
                    this.recordingNotes.set(note, { startTime: performance.now() });
                }

                const frequency = this.noteFrequencies[note];
                if (!frequency && this.settings.waveform !== 'noise') return;

                const { mainSource, modulator } = this.createMainSourceNode(this.audioContext, frequency);
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                const now = this.audioContext.currentTime;
                filter.type = 'lowpass';
                filter.frequency.value = this.settings.filterFreq;
                filter.Q.value = this.settings.filterQ;
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(this.settings.volume, now + this.settings.attack);
                mainSource.connect(filter).connect(gainNode).connect(this.audioContext.destination);
                mainSource.start();
                if (modulator) modulator.start();
                this.activeOscillators.set(note, { mainSource, gainNode, modulator });
            }

            stopNote(note) {
                const nodeData = this.activeOscillators.get(note);
                if (!nodeData) return;

                const { mainSource, gainNode, modulator } = nodeData;
                const now = this.audioContext.currentTime;
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + this.settings.release);
                const stopTime = now + this.settings.release + 0.1;
                mainSource.stop(stopTime);
                if (modulator) modulator.stop(stopTime);
                this.activeOscillators.delete(note);

                // FIX: Restore chord recording logic
                if (this.isRecording && this.recordingNotes.has(note)) {
                    const startTime = this.recordingNotes.get(note).startTime;
                    let duration = performance.now() - startTime;
                    if (duration < 50) duration = 200;
                    else duration = Math.round(duration / 10) * 10;

                    this.completedNotesBuffer.push({ note, duration });
                    this.recordingNotes.delete(note);

                    clearTimeout(this.writeBufferTimeout);
                    this.writeBufferTimeout = setTimeout(() => this.writeRecordedNotes(), 100);
                }
            }

            writeRecordedNotes() {
                if (this.completedNotesBuffer.length === 0) return;

                const maxDuration = Math.max(...this.completedNotesBuffer.map(n => n.duration));
                const noteString = this.completedNotesBuffer
                    .map(n => `${n.note} ${maxDuration}`)
                    .join(' | ');
                
                this.insertTextAtCursor(noteString);
                this.completedNotesBuffer = [];
            }

            insertTextAtCursor(text) {
                const textarea = this.sequencerCodeEl;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const textBefore = textarea.value.substring(0, start);
                const textAfter = textarea.value.substring(end, textarea.value.length);
                
                const prefix = (start === 0 || textarea.value[start - 1] === '\n') ? '' : '\n';

                textarea.value = textBefore + prefix + text + '\n' + textAfter;
                
                const newCursorPos = start + prefix.length + text.length + 1;
                textarea.selectionStart = newCursorPos;
                textarea.selectionEnd = newCursorPos;

                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                textarea.focus();
            }

            createMainSourceNode(audioCtx, frequency) {
                let mainSource, modulator;
                switch (this.settings.waveform) {
                    case 'pulse':
                        mainSource = audioCtx.createOscillator();
                        mainSource.setPeriodicWave(this.createPulseWave(audioCtx, this.settings.pulseWidth));
                        mainSource.frequency.value = frequency;
                        break;
                    case 'noise':
                        mainSource = audioCtx.createBufferSource();
                        const bufferSize = audioCtx.sampleRate * 0.5;
                        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }
                        mainSource.buffer = noiseBuffer;
                        mainSource.loop = true;
                        break;
                    case 'fm':
                        const carrier = audioCtx.createOscillator();
                        carrier.type = 'sine';
                        carrier.frequency.value = frequency;
                        modulator = audioCtx.createOscillator();
                        modulator.type = 'sine';
                        modulator.frequency.value = frequency * 2;
                        const fmDepthGain = audioCtx.createGain();
                        fmDepthGain.gain.value = this.settings.fmDepth;
                        modulator.connect(fmDepthGain);
                        fmDepthGain.connect(carrier.frequency);
                        mainSource = carrier;
                        break;
                    default:
                        mainSource = audioCtx.createOscillator();
                        mainSource.type = this.settings.waveform;
                        mainSource.frequency.value = frequency;
                }
                return { mainSource, modulator };
            }

            createPulseWave(audioCtx, dutyCycle) {
                const K = 100;
                const real = new Float32Array(K);
                const imag = new Float32Array(K);
                for (let n = 1; n < K; n++) {
                    const c = (1 / (n * Math.PI)) * Math.sin(n * Math.PI * dutyCycle);
                    real[n] = c * 2 * Math.cos(n * Math.PI * dutyCycle);
                    imag[n] = -c * 2 * Math.sin(n * Math.PI * dutyCycle);
                }
                return audioCtx.createPeriodicWave(real, imag, { disableNormalization: false });
            }

            createNoteNode(audioCtx, note, startTime, durationSec) {
                const frequency = this.noteFrequencies[note];
                if (!frequency && this.settings.waveform !== 'noise') return;

                const { mainSource, modulator } = this.createMainSourceNode(audioCtx, frequency);
                const gainNode = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                const safeStartTime = Math.max(startTime, audioCtx.currentTime);
                filter.frequency.setValueAtTime(this.settings.filterFreq, safeStartTime);
                filter.Q.setValueAtTime(this.settings.filterQ, safeStartTime);
                gainNode.gain.setValueAtTime(0, safeStartTime);
                gainNode.gain.linearRampToValueAtTime(this.settings.volume, safeStartTime + this.settings.attack);
                gainNode.gain.linearRampToValueAtTime(0, safeStartTime + durationSec + this.settings.release);
                mainSource.connect(filter).connect(gainNode).connect(audioCtx.destination);
                const stopTime = safeStartTime + durationSec + this.settings.release + 0.1;
                mainSource.start(safeStartTime);
                mainSource.stop(stopTime);
                if (modulator) {
                    modulator.start(safeStartTime);
                    modulator.stop(stopTime);
                }
            }

            scheduleSequence(audioCtx, onStep, onNote, startLineIndex) {
                const code = this.sequencerCodeEl.value;
                const allLines = code.split('\n');
                const linesToPlay = allLines.slice(startLineIndex);
                let cumulativeTime = 0;
            
                linesToPlay.forEach((line, index) => {
                    const actualLineIndex = startLineIndex + index;
                    const commands = line.split('|').map(cmd => cmd.trim());
                    let maxDurationMsOnLine = 0;
                
                    if (line.trim() === '') {
                        maxDurationMsOnLine = 250;
                    } else {
                        if (onStep) onStep(actualLineIndex, cumulativeTime);
                        commands.forEach(command => {
                            const parts = command.split(/\s+/);
                            if (parts.length < 2) return;
                            const note = parts[0].toUpperCase();
                            const durationMs = parseInt(parts[1], 10);
                            if (!isNaN(durationMs) && durationMs > 0) {
                                if (durationMs > maxDurationMsOnLine) maxDurationMsOnLine = durationMs;
                                this.createNoteNode(audioCtx, note, cumulativeTime / 1000, durationMs / 1000);
                                if (onNote) onNote(note, cumulativeTime, durationMs);
                            }
                        });
                    }
                    if (maxDurationMsOnLine === 0 && line.trim() !== '') maxDurationMsOnLine = 100;
                    cumulativeTime += maxDurationMsOnLine;
                });
                return cumulativeTime;
            }

            calculateSequenceDuration() {
                const code = this.sequencerCodeEl.value;
                const lines = code.split('\n');
                let cumulativeTime = 0;
                lines.forEach((line) => {
                    const commands = line.split('|').map(cmd => cmd.trim());
                    let maxDurationMsOnLine = 0;
                    if (line.trim() === '') {
                        maxDurationMsOnLine = 250;
                    } else {
                        commands.forEach(command => {
                            const parts = command.split(/\s+/);
                            if (parts.length >= 2) {
                                const durationMs = parseInt(parts[1], 10);
                                if (!isNaN(durationMs) && durationMs > 0 && durationMs > maxDurationMsOnLine) {
                                    maxDurationMsOnLine = durationMs;
                                }
                            }
                        });
                    }
                    if (maxDurationMsOnLine === 0 && line.trim() !== '') maxDurationMsOnLine = 100;
                    cumulativeTime += maxDurationMsOnLine;
                });
                return cumulativeTime;
            }
            
            encodeBufferToMp3(audioBuffer) {
                const sampleRate = audioBuffer.sampleRate;
                const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, 128);
                const samples = audioBuffer.getChannelData(0);
                const sampleBlockSize = 1152;
                const mp3Data = [];
            
                for (let i = 0; i < samples.length; i += sampleBlockSize) {
                    const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                    const int16Chunk = new Int16Array(sampleChunk.length);
                    for (let j = 0; j < sampleChunk.length; j++) int16Chunk[j] = sampleChunk[j] * 32767;
                    
                    const mp3buf = mp3encoder.encodeBuffer(int16Chunk);
                    if (mp3buf.length > 0) mp3Data.push(mp3buf);
                }
                const end = mp3encoder.flush();
                if (end.length > 0) mp3Data.push(end);

                return mp3Data;
            }

            updateHighlight(lineNumber) {
                if (!this.highlightBarEl) return;
                
                if (lineNumber < 0) {
                    this.highlightBarEl.style.display = 'none';
                    return;
                }
                
                const lineHeight = parseFloat(getComputedStyle(this.sequencerCodeEl).lineHeight);
                const highlightY = lineNumber * lineHeight;

                this.highlightBarEl.style.height = `${lineHeight}px`;
                this.highlightBarEl.style.top = `${highlightY}px`;
                this.highlightBarEl.style.display = 'block';
            
                this.lineNumbersEl.childNodes.forEach((div, index) => {
                    div.classList.toggle('active', index === lineNumber);
                });

                const editor = this.sequencerCodeEl;
                const editorScrollTop = editor.scrollTop;
                const editorHeight = editor.clientHeight;
                
                if (highlightY < editorScrollTop || highlightY >= editorScrollTop + editorHeight) {
                    editor.scrollTop = highlightY - (editorHeight / 2) + (lineHeight / 2);
                }
            }
        }
        
        window.addEventListener('load', () => new SimpleSynthesizer());
    </script>
</body>
</html>
